# Virtual Machine

This project is a three-stage program that translates a custom virtual machine bytecode into MIPS machine code and simulates the stack memory.

## Architecture and Flow

It takes a stack based bytecode(.o) file as input, processes it through a frontend and backend, and produces a standard MIPS assembly file(.s) and a .hex MIPS machine code instructions as outputs.

**`Input .o code`** ➡️ **`Parser (Frontend)`** ➡️ **`Intermediate Representation (IR)`** ➡️ **`MIPS Generator (Backend)`** ➡️ **`Output .s File & MIPS machine code`** ➡️ **`MIPS Assembler`** ➡️ **`Output.hex`**

1.  **Input File (`.o format`)**: A stack based byte code.
    Sample input( .o equivalent of the following vm code):
    ```.o=
    4B41545308000000
    010D000000
    010A000000
    15
    0102000000
    18
    1A0100
    1A0000
    04
    ```
2.  **Output File (`.s` & `.hex/.bin`)**: A text file containing the final MIPS assembly code, and .hex MIPS machine code which can be tested using qemu-mips. The .s file can also converted to MIPS equivalent elf file and can be tested using qemu-mips


## Components

The project is broken down into three main components:

### 1. Parser (`parser.cpp`, `parser.hpp`)

The parser acts as the **compiler's frontend**. Its primary responsibility is to read the source `.o` byte code and perform lexical and syntactic analysis to produce the Intermediate Representation. It handles:
- Reading hexadecimal strings from the input code.
- Validating the "OATS" magic number and instruction count in the header.
- Translating each bytecode opcode and its operands into an `Instruction` struct.

### 2. MIPS Generator (`mips_generator.cpp`, `mips_generator.hpp`)

The generator is the **compiler's backend**. It takes the platform-agnostic IR from the parser and generates code for a specific target architecture, which in this case is MIPS. It translates instructions like `ICONST` and `IADD` into low-level MIPS assembly for stack manipulation and arithmetic.

### 3. Main Driver (`main.cpp`)

This file orchestrates the compilation process. It initializes the parser to create the IR from the input file and then passes that IR to the MIPS generator to produce the final assembly output file.

### 4. MIPS Assembler (`mips_assembler.cpp`, `mips_assembler.hpp`)

This file translates the assembly instructions generated by the mips_generator into equivalent hexadecimal MIPS machine code instructions(.hex). 

### 5. Register Allocator(`register_allocator.cpp`, `register_allocator.hpp`)

The Register Allocator is a crucial backend utility that manages the finite pool of temporary CPU registers (e.g., $t0-$t7). Its job is to prevent the code generator from using the same register for two different purposes at the same time.

### 6. VM Simulator(`vm_simulator.cpp`, `vm_simulator.hpp`)

This component is a stack-based virtual machine designed to directly run the compiler's intermediate representation (IR). It acts as a simulated CPU, allowing the program to be executed and tested without needing to be compiled to final machine code.

## How to Compile and Run

- Clone the repository using the following command
    ```bash!
    git clone https://github.com/SaiMadhavChakrala/MIPS_Virtual_Machine/
    ```
- Compile the code by running the following commands at the root directory of the repository
    ```bash!
    cd Parser/src
    g++ main.cpp parser.cpp mips_generator.cpp mips_assembler.cpp register_allocator.cpp vm_simulator -o vm_parser -std=c++17
    ```
- Write the output from the assembler or custom vm byte code in the program.txt inside the src folder.
- Run the following to generate output.s which contains the MIPS assembly
    ```bash
    ./vm_parser input.o
    ```
- The input.o is obtained as output from the Assembler&Linker Team.

## Modules
For module-wise analysis, read the following files

https://hackmd.io/@saimadhavchakrala/BJ3ZUUxcgl

https://hackmd.io/@saimadhavchakrala/SJKPhOO9el

https://hackmd.io/@saimadhavchakrala/H1O355Rige

## Future work
Currently the VM translated the .o/byte code into hexadecimal instructions and .s files. The output instructions should be simplified to reduce the complexity of the processor. Along with stack simulation, memory simulation has yet to be implemented.
